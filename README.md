# Advanced Graphics: Path Tracer in RUST
## Arian van Putten $4133935$ and Reinier Maas $4131495$

# Collaboration
For the course `Concepts of Program Design` Arian van Putten and Reinier Maas were in the same team.
Although we were both working on different projects within this team.
Arian was working on a path tracer in Rust, because this is a realworld use-case for `Fearless concurrency` a selling point of the language.
Reinier was working together with Adolfo Ochagav√≠a on implementing different backends for an exercise from `Concurrency`, to document these.

The third assignment for `Advanced Graphics` came up, implement a path tracer.
I decided to check with Wouter Swierstra and Jacco Bikker if I could work together with Arian on implementing the path tracer.
Both because I find the language interesting and because I had done the past two assingments without a practicum partner.
This was allowed with which I'm very pleased.

Arian mainly focused on the `Fearless concurrency` part, thread scheduling without unsafe code to check how smart the compiler is.
Reinier mainly focused on implementing `Variance reduction` strategies, these were explained during the lectures.
Large parts are our combined effort.

# Physically based rendering: Path tracer
## Implementation
### Parallelism
For parallelizin the work of the path tracer we used a `scoped_threadpool` this is implemented as a library.
We enter the scope and can execute work without dependecies easily acros different threads.

### Realistic materials
#### Emissive
Emissive materials give light to a scene.
Their color component is the multiplication of it's intensity and it's actual color.
This saves recalculating the value on every evaluation.

#### Diffuse
Diffuse materials reflect light from an arbitrary direction.
While specular material reflect light from an mirrored direction.
Diffuse surfaces have an color component representing the color of the material.
As well as a speculaty component which indicates the reflectiveness of the material.

#### Dielectric
Dielectric materials are glass and water for example.
These materials absorb color the longer a ray stays inside the material.
This absorbance is according to `Beer's law` and is represented in the color component.
The mesh is defined as being the transistion between two materials.
This is why there are two refraction indexes specified with the dielectric material.
Most of the times refraction index one will be the refraction index of air, which is `one`.
Glass and water don't only refract the light arriving at their surfaces but also reflect part of this light.
This is calculated depending on the incoming angle and the normal of the hit on the material using Schlick's approximation.
Based on this there is a chance that a ray will reflect or refract.
Because of the monte carlo integration over multiple samples this will converge to the correct solution.
Caustics are generated by random samples from a diffuse surface going through the glass and hitting a light source.
Therefore dielectric materials are as realistic in the 3D world as they are in the real world.

### Primitives
The primimitives implemented implement an trait as it is called in Rust which defines their interface.
The first primitive in our application was the sphere.
Because we used a reference image that was easily checked when using a sphere as primitive.
Before we could load meshes we needed to be able to handle triangles.

### Meshes
To make loading easy we are using a library that loads `*.obj` files.
It is inspired upon tiny object loader.
The name of the library is `tobj`.
When loading obj files we convert them to our own triangle primitive.
We try to convert materials loaded with `tobj` to our own materials.
When no material is specified it uses a given backup material.

### Bounding Volume Hierarchy
As our acceleration structure we used the BVH.
The bouding volumes used in our BVH are Access Aligned Bounding Boxes.
We split the primitves over the different nodes of the BVH using the Surface Area Heuristic.
We use a three axis binned approach as our split-plane selector.
This creates 24 different bins 8 acros each axis.
This gives us 21 different split-planes that are estimated with the SAH.
The SAH calculates the surface area of the AABB and multiplies this with the number of primitives inside.
Doing this for both sides of a split-plane and adding those togehter.
Eventually selecting the lowest estimated value if that is lower then the SAH of the parent node.
This happens recursively for each node until there are no primitives to split-up or the SAH estimates it is cheaper to leave the node alone.

### Compiler checked code
Because Arian's research in this path tracer we had to use as little unsafe as possible.
Unsafe code is not checked by the compiler and can do anything arbitrary, like introducing undefined behaviour.
In our code we only have _one_ line of unsafe code.
This specific line reads bytes from disk and transmutes them into floats for our skybox.

## Variance reduction
### Important Sampling
Light on a diffuse surface gets reflected more if it arrives from the normal.
The random samples on a diffuse surface has an average chance of being sampled so the pdf is $1 / 2 \pi$.
When using the cosine weighted diffuse reflection, the sample has a greater chance of being sampled so the pdf is $R.dot(N) / \pi$.

### Next Event Estimation
On each diffuse surface we directly sample a random point on a random light.
Splits the direct and indirect illumination.

### Russian Roulette
If we are at a diffuse surface and we would do a diffuse bounce.
We give the ray a chance to survive.
$$max(transport.R, transport.G, transport.B, 0.1)$$
With this formula the ray has a chance to die corresponding to it's hightes color channel.
The minimum chance it has is to survive is 10%.
This way rays that have a greater chance to transport energy will survive longer.
After a portion of the rays are killed we need to increase the energy returned by the rays that didn't get killed.
We scale them up by dividing them by their survival rate.
